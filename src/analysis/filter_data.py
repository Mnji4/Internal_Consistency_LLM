import json
import os
import re
from src.config import config

def normalize_logic_answer(text):
    """
    Look for True, False, Uncertain in the text.
    Standardize to match Folio labels.
    """
    text = text.lower()
    # Simple keyword spotting. 
    # Use prioritization: if multiple exist, pick the last one or the one most likely to be the answer?
    # Usually the model outputs "Answer: True".
    
    if "uncertain" in text:
        return "Uncertain"
    if "false" in text:
        return "False"
    if "true" in text:
        return "True"
        
    # Fallback
    return "Unknown"

def main():
    input_file = os.path.join(config.OUTPUT_DIR, "inference_results.jsonl")
    output_file = os.path.join(config.DATA_DIR, "sft_train.jsonl")
    
    if not os.path.exists(input_file):
        print(f"File not found: {input_file}")
        return

    data = []
    with open(input_file, 'r') as f:
        for line in f:
            data.append(json.loads(line))

    filtered_samples = []
    stats = {"total": len(data), "valid_simple": 0, "conflict": 0, "selected": 0}
    
    for item in data:
        ans_gt = item['ground_truth'] # Folio labels are already strings
        
        ans_simple = normalize_logic_answer(item['response_simple'])
        ans_complex = normalize_logic_answer(item['response_complex'])
        
        # Strategy B: Trust Simple only if matches GT
        if ans_simple == ans_gt:
            stats["valid_simple"] += 1
            
            if ans_simple != ans_complex:
                stats["conflict"] += 1
                
                # Construct SFT
                # Model should ignore noise and output the Correct Simple Answer (or reasoning)
                # Ideally we want the reasoning too? 
                # Since we don't have reasoning in GT, we use the simple response text as target 
                # (assuming simple response contains reasoning if generated by CoT, 
                # but currently we just asked for answer. Maybe we should have asked for CoT?)
                
                # Let's trust the 'response_simple' text as the target.
                
                training_entry = {
                    "messages": [
                        {"role": "user", "content": item['complex_prompt']},
                        {"role": "assistant", "content": item['response_simple']}
                    ]
                }
                filtered_samples.append(training_entry)
                stats["selected"] += 1

    with open(output_file, 'w') as f:
        for entry in filtered_samples:
            f.write(json.dumps(entry) + "\n")
            
    print("Filtering complete.")
    print(json.dumps(stats, indent=2))
    print(f"Saved {len(filtered_samples)} samples to {output_file}")

if __name__ == "__main__":
    main()
